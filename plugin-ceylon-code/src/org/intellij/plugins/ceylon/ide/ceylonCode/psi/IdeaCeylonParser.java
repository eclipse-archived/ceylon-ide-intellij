package org.intellij.plugins.ceylon.ide.ceylonCode.psi;

import java.util.ArrayList;
import java.util.Arrays;
import java.util.Collections;
import java.util.Comparator;
import java.util.LinkedList;
import java.util.List;
import java.util.Queue;

import org.antlr.runtime.ANTLRStringStream;
import org.antlr.runtime.CommonToken;
import org.antlr.runtime.CommonTokenStream;
import org.antlr.runtime.RecognitionException;
import org.antlr.runtime.Token;
import org.jetbrains.annotations.NotNull;

import com.intellij.codeInsight.completion.CompletionInitializationContext;
import com.intellij.lang.ASTNode;
import com.intellij.lang.Language;
import com.intellij.openapi.application.ApplicationManager;
import com.intellij.openapi.diagnostic.Logger;
import com.intellij.openapi.editor.Document;
import com.intellij.openapi.util.Key;
import com.intellij.openapi.util.Ref;
import com.intellij.openapi.vfs.VirtualFile;
import com.intellij.psi.PsiDocumentManager;
import com.intellij.psi.PsiElement;
import com.intellij.psi.TokenType;
import com.intellij.psi.impl.source.tree.CompositeElement;
import com.intellij.psi.impl.source.tree.LeafPsiElement;
import com.intellij.psi.impl.source.tree.PsiWhiteSpaceImpl;
import com.intellij.psi.impl.source.tree.TreeElement;
import com.intellij.psi.tree.IElementType;
import com.intellij.psi.tree.IStubFileElementType;
import com.redhat.ceylon.compiler.typechecker.context.PhasedUnit;
import com.redhat.ceylon.compiler.typechecker.parser.CeylonLexer;
import com.redhat.ceylon.compiler.typechecker.parser.CeylonParser;
import com.redhat.ceylon.compiler.typechecker.parser.LexError;
import com.redhat.ceylon.compiler.typechecker.parser.ParseError;
import com.redhat.ceylon.compiler.typechecker.tree.Node;
import com.redhat.ceylon.compiler.typechecker.tree.Tree;
import com.redhat.ceylon.compiler.typechecker.tree.Visitor;
import com.redhat.ceylon.ide.common.typechecker.ExternalPhasedUnit;
import com.redhat.ceylon.ide.common.typechecker.LocalAnalysisResult;
import com.redhat.ceylon.ide.common.typechecker.ProjectPhasedUnit;

/**
 * This class avoids calling a custom parser. Instead, we transform the Ceylon AST generated by
 * the official parser into an ASTNode tree. Comments and whitespaces are not present in the Ceylon AST,
 * but we can retrieve them by synchronizing our transformation with a lexer.
 */
public class IdeaCeylonParser extends IStubFileElementType {

    private static Logger LOGGER = Logger.getInstance(IdeaCeylonParser.class);

    private static final List<Integer> NODES_ALLOWED_AT_EOF = Arrays.asList(CeylonLexer.EOF,
            CeylonLexer.WS, CeylonLexer.LINE_COMMENT, CeylonLexer.MULTI_COMMENT);

    // Leaves which will be wrapped in a CeylonCompositeElement, for example to allow refactoring them
    private static final List<IElementType> LEAVES_TO_WRAP = Arrays.asList(CeylonTypes.IDENTIFIER,
            CeylonTypes.NATURAL_LITERAL, CeylonTypes.FUNCTION_LITERAL, CeylonTypes.STRING_LITERAL);

    public static final Key<Node> CEYLON_NODE_KEY = new Key<>("CEYLON-SPEC_NODE");
    public static final Key<Tree.CompilationUnit> FORCED_CU_KEY = new Key<>("CEYLON-FORCED_CU");

    public IdeaCeylonParser(Language language) {
        super(language);
    }

    @Override
    protected ASTNode doParseContents(@NotNull ASTNode chameleon, @NotNull PsiElement psi) {
        CeylonFile file = (CeylonFile) psi;
        final Queue<Token> tokens = new LinkedList<>();
        boolean verbose = false;
        final Ref<CommonToken> lastToken = new Ref<>();
        
        PsiDocumentManager psiManager = PsiDocumentManager.getInstance(file.getProject());
        VirtualFile virtualFile;
        Document lastCommittedDocument;
        if (file.getOriginalFile() != null) {
            lastCommittedDocument = psiManager.getLastCommittedDocument(file.getOriginalFile());
            virtualFile = file.getOriginalFile().getVirtualFile();
        } else {
            lastCommittedDocument = psiManager.getLastCommittedDocument(file); 
            virtualFile = file.getVirtualFile();
        }
        CeylonLocalAnalyzer localAnalyzer = lastCommittedDocument == null ? null : file.getLocalAnalyzer();
                        
        CeylonLexer lexer = new CeylonLexer(new ANTLRStringStream(file.getText())) {
            @Override
            public Token nextToken() {
                CommonToken token = (CommonToken) super.nextToken();

                if (token != null) {
                    int lastStopIndex = -1;
                    if (!lastToken.isNull()) {
                        lastStopIndex = lastToken.get().getStopIndex();
                    }
                    if (token.getType() != EOF
                            && lastStopIndex != token.getStartIndex() - 1) {
                        CommonToken badToken = new CommonToken(token.getInputStream(), -2, 0,
                                lastStopIndex + 1,
                                token.getStartIndex() - 1);
                        tokens.add(badToken);
                    }
                    tokens.add(token);
                    lastToken.set(token);
                }

                return token;
            }
        };

        CommonTokenStream stream = new CommonTokenStream(lexer);
        stream.fill();

        CeylonParser parser = new CeylonParser(stream);

        try {
            CompilationUnitTranslator translator = new CompilationUnitTranslator(file, tokens, verbose);
            
            Tree.CompilationUnit parsedCompilationUnit = parser.compilationUnit();
            if (isInSourceArchive_.isInSourceArchive(virtualFile)
                    && localAnalyzer != null) {
                    LocalAnalysisResult localAnalysisResult = localAnalyzer.getResult();
                    if (localAnalysisResult != null) {
                        PhasedUnit lastPhasedUnit = localAnalysisResult.getLastPhasedUnit();
                        if (lastPhasedUnit instanceof ExternalPhasedUnit) {
                            ExternalPhasedUnit externalPu = (ExternalPhasedUnit) lastPhasedUnit;
                            ASTNode root = translator.translateToAstNode(externalPu.getCompilationUnit());
                            localAnalyzer.translatedExternalSource(lastCommittedDocument, externalPu);
                            return root;
                        }
                    }
            }

            if (localAnalyzer == null) {
                ProjectPhasedUnit projectPhasedUnit = file.retrieveCorrespondingPhasedUnit();
                if (projectPhasedUnit != null) {
                    ASTNode root = translator.translateToAstNode(projectPhasedUnit.getCompilationUnit());
                    return root;
                }
            }
            ASTNode root = translator.translateToAstNode(parsedCompilationUnit);
            if (localAnalyzer != null
                    && !file.getText().contains(CompletionInitializationContext.DUMMY_IDENTIFIER_TRIMMED)) {
                localAnalyzer.parsedProjectSource(
                        lastCommittedDocument,
                        parsedCompilationUnit,
                        stream.getTokens());
            }

            for (ParseError error : parser.getErrors()) {
                parsedCompilationUnit.addParseError(error);
            }
            for (LexError error : lexer.getErrors()) {
                parsedCompilationUnit.addLexError(error);
            }

            return root;
        } catch (RecognitionException e) {
            e.printStackTrace();
        }
        return null;
    }

    // For debugging purposes only
    private void dump(ASTNode root, String indent) {
        System.out.println(indent + root.getElementType() + (root instanceof LeafPsiElement ? " (" + root.getText() + ")" : ""));
        for (ASTNode child : root.getChildren(null)) {
            dump(child, indent + "  ");
        }
    }

    private class CompilationUnitTranslator extends Visitor {
        private CompositeElement parent;
        private CeylonFile file;
        private Queue<Token> tokens;
        private boolean verbose;
        private int index = 0;

        public CompilationUnitTranslator(CeylonFile file, Queue<Token> tokens, boolean verbose) {
            this.file = file;
            this.tokens = tokens;
            this.verbose = verbose;
        }

        public ASTNode translateToAstNode(Tree.CompilationUnit cu) {
            visit(cu);

            ASTNode root = parent;
            if (verbose) {
                dump(root, "");
            }
            return root;
        }
        
        @Override
        public void visit(Tree.CompilationUnit that) {
            super.visit(that);

            while (!tokens.isEmpty()) {
                Token token = tokens.remove();

                if (token.getType() != CeylonLexer.EOF) {
                    parent.rawAddChildrenWithoutNotifications(buildLeaf(null, getElementType(token.getType()), token));
                }

                if (verbose && !NODES_ALLOWED_AT_EOF.contains(token.getType())) {
                    Logger.getInstance(IdeaCeylonParser.class).error("Unexpected token " + token + " in " + file.getName());
                }
            }
            
            final int[] parentAndFileTextLength = new int[2];
            ApplicationManager.getApplication().runReadAction(new Runnable() {
                @Override
                public void run() {
                    parentAndFileTextLength[0] = parent.getTextLength();
                    parentAndFileTextLength[1] = file.getTextLength();
                }
            });
            int parentTextLength = parentAndFileTextLength[0];
            int fileTextLength = parentAndFileTextLength[1];
            if (parentTextLength < fileTextLength) {
                String notParsed = file.getText().substring(parentTextLength);
                parent.rawAddChildrenWithoutNotifications(new LeafPsiElement(TokenType.BAD_CHARACTER, notParsed));
            }
        }

        @Override
        public void visitAny(Node that) {
            IElementType type = NodeToIElementTypeMap.get(that);
            boolean parentForced = false;

            if (type == null) {
                LOGGER.error("Unknown IElementType for " + that + " in " + that.getUnit().getFullPath());
                return;
            }
            if (parent == null) {
                parentForced = true;
                parent = new CompositeElement(type);
            }

            if (that instanceof Tree.DocLink) {
                return;
            }
            index = consumeTokens(that, index, true);

            Token token = that.getMainToken();

            OrderedChildrenVisitor visitor = new OrderedChildrenVisitor();
            try {
                that.visitChildren(visitor);
            } catch (Exception e) {
                that.handleException(e, visitor);
            }

            if (that.getToken() != null && visitor.children.isEmpty()) {
                Token peek = tokens.peek();
                if (getTokenLength(peek) == that.getEndIndex() - that.getStartIndex()) {
                    Token toRemove = tokens.remove();
                    parent.rawAddChildrenWithoutNotifications(buildLeaf(that, type, toRemove));
                    if (verbose) {
                        System.out.println("t \"" + toRemove.getText() + "\"");
                    }
                    index += getTokenLength(toRemove);
                } else {
                    CompositeElement comp = new CompositeElement(type);

                    while (index < that.getEndIndex()) {
                        Token toRemove = tokens.remove();
                        comp.rawAddChildrenWithoutNotifications(buildLeaf(null, getElementType(token.getType()), toRemove));
                        if (verbose) {
                            System.out.println("t \"" + toRemove.getText() + "\"");
                        }
                        index += getTokenLength(toRemove);
                    }

                    parent.rawAddChildrenWithoutNotifications(comp);
                }

                // TODO should be == but sometimes the tree includes a node that was already included before
                // (see `exists` constructs for example)
                assert index >= that.getEndIndex();
            } else {
                CompositeElement oldParent = parent;
                if (!parentForced) {
                    parent = new CompositeElement(type);
                    oldParent.rawAddChildrenWithoutNotifications(parent);
                }
                parent.putUserData(CEYLON_NODE_KEY, that);

                for (Node child : visitor.getChildren()) {
                    visitAny(child);
                }

                index = consumeTokens(that, index, false);

                parent = oldParent;
            }
        }

        private IElementType getElementType(int idx) {
            if (idx == -2) {
                return TokenType.BAD_CHARACTER;
            }
            return TokenTypes.fromInt(idx);
        }

        @NotNull
        private TreeElement buildLeaf(Node ceylonNode, IElementType type, Token token) {
            String tokenText = token.getText();
            if (tokenText.length() != getTokenLength(token)) {
                switch (token.getType()) {
                    case CeylonLexer.PIDENTIFIER:
                    case CeylonLexer.AIDENTIFIER:
                    case CeylonLexer.LIDENTIFIER:
                        tokenText = "\\i" + tokenText;
                        break;
                    case CeylonLexer.UIDENTIFIER:
                        tokenText = "\\I" + tokenText;
                        break;
                    default:
                        throw new UnsupportedOperationException("Unsupported token type " + token);
                }
            }
            if (LEAVES_TO_WRAP.contains(type)) {
                CompositeElement comp = new CompositeElement(type);
                LeafPsiElement leaf = new LeafPsiElement(TokenTypes.fromInt(token.getType()), tokenText);
                comp.rawAddChildrenWithoutNotifications(leaf);
                comp.putUserData(CEYLON_NODE_KEY, ceylonNode);
                return comp;
            } else if (type == TokenType.WHITE_SPACE || token.getType() == CeylonLexer.WS) {
                return new PsiWhiteSpaceImpl(tokenText);
            } else {
                return new LeafPsiElement(getElementType(token.getType()), tokenText);
            }
        }

        private int consumeTokens(Node that, int index, boolean before) {
            Integer targetIndex = before ? that.getStartIndex() : that.getEndIndex();

            if (targetIndex == null) {
                return index;
            }

            if (index > targetIndex) {
                if (verbose) {
                    System.out.println(String.format("WARN : index (%d) > targetIndex (%d)", index, targetIndex));
                }
                return index;
            }

            while (index < targetIndex) {
                Token token = tokens.remove();
                String text = token.getText();
                if (text.endsWith("\n")) {
                    parent.rawAddChildrenWithoutNotifications(new LeafPsiElement(getElementType(token.getType()),
                            text.substring(0, text.length()-1)));
                    parent.rawAddChildrenWithoutNotifications(new PsiWhiteSpaceImpl("\n"));
                }
                else {
                    parent.rawAddChildrenWithoutNotifications(buildLeaf(null, getElementType(token.getType()), token));
                }
                index += getTokenLength(token);
                if (verbose) {
                    System.out.println("c \"" + text + "\"");
                }
            }

            assert index == targetIndex;

            return index;
        }

        private int getTokenLength(Token token) {
            if (token instanceof CommonToken) {
                CommonToken commonToken = (CommonToken) token;
                return commonToken.getStopIndex() - commonToken.getStartIndex() + 1;
            } else {
                return token.getText().length();
            }
        }
    }

    private class OrderedChildrenVisitor extends Visitor {
        List<Node> children = new ArrayList<>();

        @Override
        public void visitAny(Node that) {
            children.add(that);
        }

        public List<Node> getChildren() {
            Collections.sort(children, new Comparator<Node>() {
                @Override
                public int compare(@NotNull Node o1, @NotNull Node o2) {
                    Integer idx1 = o1.getStartIndex();
                    Integer idx2 = o2.getStartIndex();

                    if (idx1 == null) {
                        return idx2 == null ? 0 : 1;
                    }
                    if (idx2 == null) {
                        return -1;
                    }

                    return idx1.compareTo(idx2);
                }
            });

            return children;
        }
    }
}
